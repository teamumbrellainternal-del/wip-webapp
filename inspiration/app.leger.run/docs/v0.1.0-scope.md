# Leger v0.1.0: Web Application & Backend Specification

**Document Version:** 3.0 (Complete Rewrite)  
**Date:** October 2025  
**Status:** Authoritative - Aligned with Production CLI

**Scope:** Minimum viable web application for secret management and release tracking, designed to complement the fully-implemented Leger CLI.

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Architecture Overview](#architecture-overview)
3. [Authentication System](#authentication-system)
4. [Secret Management](#secret-management)
5. [Release Management](#release-management)
6. [Data Models](#data-models)
7. [API Endpoints](#api-endpoints)
8. [Frontend Pages](#frontend-pages)
9. [Infrastructure Setup](#infrastructure-setup)
10. [Deployment](#deployment)
11. [Success Criteria](#success-criteria)

---

## Executive Summary

### What v0.1.0 Delivers

**Core Functionality:**
1. ✅ JWT-based authentication (CLI-initiated)
2. ✅ Web UI for API secret management (CRUD)
3. ✅ Encrypted secret storage in Cloudflare KV
4. ✅ CLI endpoint to sync secrets (download from KV)
5. ✅ Release tracking (GitHub repo URLs)
6. ✅ User account management

**Infrastructure Preparation:**
- R2 bucket created (minimal setup for v0.2.0)
- D1 database with full schema
- KV namespaces configured
- Static hosting foundation

### Critical Clarifications

**What v0.1.0 Is NOT:**
- ❌ No template rendering (v0.2.0+)
- ❌ No configuration UI (29 variables) - v0.2.0+
- ❌ No serving quadlets from leger.run - v0.2.0+
- ❌ No upload of quadlets from CLI
- ❌ No "bundles" concept

**v0.1.0 Reality:**
- Users enter secrets via web UI
- CLI syncs secrets from KV to local setec
- Users store GitHub repo URLs as "releases"
- CLI clones from GitHub repos (not leger.run yet)
- R2 infrastructure exists but unused in v0.1.0

---

## Architecture Overview

### System Components

```
┌─────────────────────────────────────────────────────────────┐
│                     User's Machine                          │
│  ┌──────────────┐         ┌──────────────┐                 │
│  │ Web Browser  │         │  Leger CLI   │                 │
│  │   (React)    │         │   (Go)       │                 │
│  └──────┬───────┘         └──────┬───────┘                 │
│         │ 1. Opens with JWT      │ 2. API calls           │
│         │                         │    with JWT            │
└─────────┼─────────────────────────┼─────────────────────────┘
          │                         │
          │   HTTPS + JWT           │   HTTPS + JWT
          ▼                         ▼
┌─────────────────────────────────────────────────────────────┐
│              app.leger.run (Cloudflare Workers)             │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  Worker Routes:                                       │ │
│  │  • POST /api/auth/validate   → Validate CLI JWT      │ │
│  │  • GET  /api/secrets         → List secrets          │ │
│  │  • POST /api/secrets/:name   → Create secret         │ │
│  │  • GET  /api/secrets/:name   → Get secret            │ │
│  │  • DELETE /api/secrets/:name → Delete secret         │ │
│  │  • GET  /api/releases        → List releases         │ │
│  │  • POST /api/releases        → Create release        │ │
│  │  • /*                        → Serve React SPA       │ │
│  └───────────────────────────────────────────────────────┘ │
│         │                  │                  │             │
│         ▼                  ▼                  ▼             │
│  ┌──────────┐      ┌──────────┐      ┌──────────┐         │
│  │  KV      │      │  D1      │      │  R2      │         │
│  │ Secrets  │      │  Users   │      │(unused)  │         │
│  │  +Users  │      │ Releases │      │          │         │
│  └──────────┘      └──────────┘      └──────────┘         │
└─────────────────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────────────────┐
│                     User's Machine                          │
│  ┌──────────────┐         ┌──────────────┐                 │
│  │    setec     │◄────────│  Leger CLI   │                 │
│  │  (legerd)    │ writes  │              │                 │
│  └──────┬───────┘         └──────────────┘                 │
│         │                         │                         │
│         ▼                         ▼                         │
│  ┌──────────────┐         ┌──────────────┐                 │
│  │   Podman     │         │ Git Clone    │                 │
│  │  Secrets     │         │ GitHub Repos │                 │
│  └──────────────┘         └──────────────┘                 │
└─────────────────────────────────────────────────────────────┘
```

### Data Flow

**Secret Management:**
```
User enters secret in webapp
    ↓
Encrypted & stored in KV
    ↓
CLI: leger secrets sync
    ↓
CLI fetches from KV (decrypted by backend)
    ↓
CLI writes to local setec/legerd
    ↓
legerd creates Podman secrets
    ↓
Containers access via Secret= directive
```

**Deployment (v0.1.0):**
```
User saves GitHub repo URL in webapp
    ↓
Stored as "release" in D1
    ↓
CLI: leger deploy install --release {name}
    ↓
CLI fetches release metadata from leger.run
    ↓
CLI: git clone {github_url}
    ↓
CLI: podman quadlet install --user {path}
```

**Deployment (v0.2.0+ Future):**
```
User configures via webapp (29 variables)
    ↓
Backend renders templates server-side
    ↓
Published to R2: static.leger.run/{uuid}/latest/
    ↓
CLI: git clone https://static.leger.run/{uuid}/latest/
    ↓
CLI: podman quadlet install --user {path}
```

---

## Authentication System

### JWT-Based Authentication Flow

**Prerequisites:**
- User has Tailscale running on local machine
- Leger CLI is installed and functional
- CLI has JWT generation capability (separate GitHub issue)

### Complete Flow

```
┌─────────────────────────────────────────────────────────────┐
│ Step 1: User Initiates Login                                │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
         $ leger auth login
                      │
                      ▼
    ┌────────────────────────────────────────────────┐
    │ CLI Process:                                   │
    │ 1. Extract Tailscale identity locally          │
    │    - tailscale status --json                   │
    │    - Get: user_id, email, tailnet, device_id   │
    │                                                 │
    │ 2. Generate JWT (CLI-side)                     │
    │    - Sign with shared secret                   │
    │    - Include: user_id, email, tailnet          │
    │    - Expiry: 30 days                           │
    │                                                 │
    │ 3. Store JWT locally                           │
    │    - ~/.local/share/leger/auth.json            │
    │                                                 │
    │ 4. Open browser with JWT                       │
    │    - https://app.leger.run/auth?token={jwt}    │
    └────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ Step 2: Browser Validates with Backend                      │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
    Browser → POST /api/auth/validate
              Header: Authorization: Bearer {jwt}
                      │
                      ▼
    ┌────────────────────────────────────────────────┐
    │ Worker Process:                                │
    │ 1. Verify JWT signature (shared secret)        │
    │ 2. Check expiration                            │
    │ 3. Extract: user_id, email, tailnet            │
    │ 4. Check D1 for existing user                  │
    │    - SELECT * FROM users                       │
    │      WHERE tailscale_user_id = ?               │
    │                                                 │
    │ 5. If new user:                                │
    │    - Generate user_uuid (UUID v5)              │
    │    - INSERT INTO users                         │
    │    - Write to KV cache                         │
    │                                                 │
    │ 6. If existing:                                │
    │    - UPDATE last_seen timestamp                │
    │                                                 │
    │ 7. Store JWT in session (browser localStorage) │
    │ 8. Redirect to /api-keys                       │
    └────────────────────────────────────────────────┘
```

### JWT Structure

```typescript
interface JWTPayload {
  sub: string;              // user_uuid (derived from tailscale_user_id)
  tailscale_user_id: string; // "u123456789"
  email: string;            // "alice@github"
  tailnet: string;          // "example.ts.net"
  iat: number;              // Issued at timestamp
  exp: number;              // Expiry (30 days from iat)
}
```

**JWT Properties:**
- Algorithm: HS256
- Secret: Shared between CLI and backend (configured in both)
- Expiry: 30 days
- No refresh tokens (user re-authenticates)

### Backend Validation Middleware

```typescript
async function validateJWT(request: Request, env: Env): Promise<JWTPayload> {
  const authHeader = request.headers.get('Authorization');
  if (!authHeader?.startsWith('Bearer ')) {
    throw new Error('Missing JWT token');
  }
  
  const token = authHeader.substring(7);
  const payload = await verifyJWT(token, env.JWT_SECRET);
  
  if (payload.exp < Date.now() / 1000) {
    throw new Error('Token expired');
  }
  
  return payload;
}
```

**All protected routes use this middleware.**

---

## Secret Management

### Architecture

**Storage Tier: Cloudflare KV**
- Namespace: `LEGER_SECRETS`
- Encryption: AES-256-GCM (server-side)
- Master key: `ENCRYPTION_KEY` (Wrangler secret)
- Key format: `secrets:{user_uuid}:{secret_name}`

**Access Pattern:**
- Web UI: Create, update, delete secrets
- CLI: Read-only access (sync operation)
- No direct access for legerd (CLI mediates)

### Secret Lifecycle

```
┌─────────────────────────────────────────────────────────────┐
│ 1. User Creates Secret (Web UI)                             │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
    POST /api/secrets/openai_api_key
    Body: { "value": "sk-proj-abc123..." }
                      │
                      ▼
    ┌────────────────────────────────────────────────┐
    │ Backend Process:                               │
    │ 1. Validate JWT → get user_uuid                │
    │ 2. Validate secret name (alphanumeric + _-)    │
    │ 3. Generate unique nonce (96 bits)             │
    │ 4. Encrypt value with AES-256-GCM              │
    │ 5. Store in KV:                                │
    │    Key: secrets:{user_uuid}:{secret_name}      │
    │    Value: {                                    │
    │      encrypted_value: "...",                   │
    │      nonce: "...",                             │
    │      version: 1,                               │
    │      created_at: "..."                         │
    │    }                                           │
    │ 6. Return success                              │
    └────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. CLI Syncs Secrets                                         │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
    $ leger secrets sync
                      │
                      ▼
    GET /api/secrets
    Header: Authorization: Bearer {jwt}
                      │
                      ▼
    ┌────────────────────────────────────────────────┐
    │ Backend Process:                               │
    │ 1. Validate JWT → get user_uuid                │
    │ 2. List KV keys: secrets:{user_uuid}:*         │
    │ 3. For each secret:                            │
    │    - Retrieve from KV                          │
    │    - Decrypt using master key                  │
    │    - Return plaintext value                    │
    │ 4. Return JSON:                                │
    │    {                                           │
    │      "secrets": [                              │
    │        {                                       │
    │          "name": "openai_api_key",             │
    │          "value": "sk-proj-abc123...",         │
    │          "version": 1                          │
    │        }                                       │
    │      ]                                         │
    │    }                                           │
    └────────────────────────────────────────────────┘
                      │
                      ▼
    ┌────────────────────────────────────────────────┐
    │ CLI Process:                                   │
    │ 1. Receive decrypted secrets                   │
    │ 2. Write to local setec/legerd:                │
    │    - leger calls setec API                     │
    │    - setec stores secrets locally              │
    │ 3. legerd creates Podman secrets:              │
    │    - podman secret create openai_api_key       │
    └────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Deployment Uses Secrets                                   │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
    Quadlet file: openwebui.container
    Secret=openai_api_key,type=env,target=OPENAI_API_KEY
                      │
                      ▼
    Podman injects from local secret store
```

### Encryption Implementation

```typescript
// Server-side encryption
async function encryptSecret(
  plaintext: string,
  masterKey: string
): Promise<SecretRecord> {
  const key = await crypto.subtle.importKey(
    'raw',
    base64Decode(masterKey),
    'AES-GCM',
    false,
    ['encrypt']
  );
  
  const nonce = crypto.getRandomValues(new Uint8Array(12));
  const data = new TextEncoder().encode(plaintext);
  
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: nonce },
    key,
    data
  );
  
  return {
    encrypted_value: base64Encode(encrypted),
    nonce: base64Encode(nonce),
    version: 1,
    created_at: new Date().toISOString()
  };
}

// Server-side decryption
async function decryptSecret(
  record: SecretRecord,
  masterKey: string
): Promise<string> {
  const key = await crypto.subtle.importKey(
    'raw',
    base64Decode(masterKey),
    'AES-GCM',
    false,
    ['decrypt']
  );
  
  const decrypted = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv: base64Decode(record.nonce) },
    key,
    base64Decode(record.encrypted_value)
  );
  
  return new TextDecoder().decode(decrypted);
}
```

**Security Properties:**
- Plaintext NEVER logged
- Master key NEVER exposed
- Unique nonce per secret
- Authentication tag prevents tampering
- Encryption/decryption server-side only

---

## Release Management

### v0.1.0 Release Model

A "release" in v0.1.0 is **metadata pointing to a GitHub repository**.

```typescript
interface Release {
  id: string;                   // UUID v4
  user_uuid: string;
  name: string;                 // "my-openwebui-setup"
  git_url: string;              // "https://github.com/user/quadlets"
  git_branch: string;           // "main"
  description: string;          // Optional description
  version: number;              // Auto-increment (1, 2, 3...)
  created_at: string;
  updated_at: string;
}
```

**Storage:**
- D1 table: `releases`
- No files stored in v0.1.0
- R2 bucket exists but unused

### Release Workflow (v0.1.0)

```
┌─────────────────────────────────────────────────────────────┐
│ 1. User Creates Release (Web UI)                            │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
    POST /api/releases
    Body: {
      "name": "my-openwebui",
      "git_url": "https://github.com/alice/quadlets",
      "git_branch": "main",
      "description": "OpenWebUI with LiteLLM"
    }
                      │
                      ▼
    ┌────────────────────────────────────────────────┐
    │ Backend Process:                               │
    │ 1. Validate JWT → get user_uuid                │
    │ 2. Validate git_url (must be valid URL)        │
    │ 3. Get next version number for user            │
    │ 4. INSERT INTO releases                        │
    │ 5. Return release metadata                     │
    └────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. CLI Deploys Release                                       │
└─────────────────────────────────────────────────────────────┘
                      │
                      ▼
    $ leger deploy install --release my-openwebui
                      │
                      ▼
    ┌────────────────────────────────────────────────┐
    │ CLI Process:                                   │
    │ 1. GET /api/releases?name=my-openwebui         │
    │    - Fetch release metadata                    │
    │                                                 │
    │ 2. git clone {git_url} -b {git_branch}         │
    │    - Clone from GitHub                         │
    │                                                 │
    │ 3. Validate quadlet files                      │
    │    - Check syntax                              │
    │    - Verify dependencies                       │
    │                                                 │
    │ 4. podman quadlet install --user {path}        │
    │    - Native Podman command                     │
    │                                                 │
    │ 5. Start services                              │
    │    - systemctl --user start openwebui.service  │
    └────────────────────────────────────────────────┘
```

### v0.2.0+ Release Model (Future)

```
User configures via webapp (29 variables)
    ↓
Backend renders templates (Nunjucks + schema)
    ↓
Generated quadlet files stored in R2
    ↓
Published to: static.leger.run/{user_uuid}/v{N}/
    ↓
CLI: git clone https://static.leger.run/{user_uuid}/latest/
    ↓
Same deployment flow as v0.1.0
```

**R2 Structure (v0.2.0+):**
```
leger-static-sites/
├── {user_uuid}/
│   ├── v1/
│   │   ├── manifest.json
│   │   ├── openwebui.container
│   │   └── ...
│   ├── v2/
│   │   └── ...
│   └── latest/  ← Symlink to latest version
│       └── ...
```

---

## Data Models

### Cloudflare KV

#### Namespace: `LEGER_USERS`

**Key:** `user:{user_uuid}`

**Value:**
```typescript
interface UserRecord {
  user_uuid: string;              // UUID v5 from tailscale_user_id
  tailscale_user_id: string;
  tailscale_email: string;
  tailnet: string;
  display_name: string | null;
  created_at: string;
  last_seen: string;
  last_device_id: string;
  metadata: {
    cli_version: string;
    total_authentications: number;
  };
}
```

---

#### Namespace: `LEGER_SECRETS`

**Key:** `secrets:{user_uuid}:{secret_name}`

**Value:**
```typescript
interface SecretRecord {
  secret_id: string;            // UUID v4
  user_uuid: string;
  name: string;                 // "openai_api_key"
  encrypted_value: string;      // Base64 AES-256-GCM ciphertext
  nonce: string;                // Base64 96-bit nonce
  encryption_version: number;   // Always 1 for v0.1.0
  version: number;              // Increments on update
  created_at: string;
  updated_at: string;
  last_accessed: string | null;
}
```

---

### Cloudflare D1

```sql
-- Users table
CREATE TABLE users (
    user_uuid TEXT PRIMARY KEY,
    tailscale_user_id TEXT NOT NULL UNIQUE,
    tailscale_email TEXT NOT NULL,
    tailnet TEXT NOT NULL,
    display_name TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_seen TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_device_id TEXT,
    cli_version TEXT,
    total_authentications INTEGER DEFAULT 0
);

CREATE INDEX idx_users_tailscale_id ON users(tailscale_user_id);

-- Releases table (v0.1.0: GitHub URLs only)
CREATE TABLE releases (
    id TEXT PRIMARY KEY,
    user_uuid TEXT NOT NULL,
    name TEXT NOT NULL,
    git_url TEXT NOT NULL,
    git_branch TEXT NOT NULL DEFAULT 'main',
    description TEXT,
    version INTEGER NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_uuid) REFERENCES users(user_uuid) ON DELETE CASCADE
);

CREATE UNIQUE INDEX idx_release_user_name ON releases(user_uuid, name);
CREATE INDEX idx_release_user ON releases(user_uuid);

-- Future tables (created but unused in v0.1.0)
CREATE TABLE configurations (
    id TEXT PRIMARY KEY,
    user_uuid TEXT NOT NULL,
    config_data JSON NOT NULL,
    schema_version TEXT NOT NULL,
    version INTEGER NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_uuid) REFERENCES users(user_uuid) ON DELETE CASCADE
);

-- (Additional v0.2.0+ tables created but not detailed here)
```

---

### Cloudflare R2

**Bucket:** `leger-static-sites` (created but empty in v0.1.0)

**Purpose:** Store rendered quadlet files in v0.2.0+

**v0.1.0 Status:** Bucket exists, no files uploaded

---

## API Endpoints

### Authentication

**POST /api/auth/validate**

**Purpose:** Validate CLI-generated JWT and establish web session

**Request:**
```
Authorization: Bearer {jwt-from-cli}
```

**Response (Success):**
```json
{
  "success": true,
  "data": {
    "user": {
      "user_uuid": "550e8400-e29b-41d4-a716-446655440000",
      "email": "alice@github",
      "display_name": "Alice",
      "tailnet": "example.ts.net"
    }
  }
}
```

**Response (Error):**
```json
{
  "success": false,
  "error": {
    "code": "invalid_token",
    "message": "JWT signature invalid or expired"
  }
}
```

---

### Secret Management

**All require:** `Authorization: Bearer {jwt}`

**GET /api/secrets**

**Purpose:** List all secrets for user (web UI) or sync all secrets (CLI)

**Query Parameters:**
- `include_values=true` (CLI only) - Return decrypted values
- `include_values=false` (default, web UI) - Return metadata only

**Response (Web UI):**
```json
{
  "success": true,
  "data": {
    "secrets": [
      {
        "name": "openai_api_key",
        "created_at": "2025-10-15T10:00:00Z",
        "updated_at": "2025-10-16T12:00:00Z",
        "version": 2
      }
    ]
  }
}
```

**Response (CLI with include_values=true):**
```json
{
  "success": true,
  "data": {
    "secrets": [
      {
        "name": "openai_api_key",
        "value": "sk-proj-abc123...",
        "version": 2,
        "created_at": "2025-10-15T10:00:00Z"
      }
    ]
  }
}
```

---

**GET /api/secrets/:name**

**Purpose:** Get single secret value (CLI only)

**Response:**
```json
{
  "success": true,
  "data": {
    "name": "openai_api_key",
    "value": "sk-proj-abc123...",
    "version": 2
  }
}
```

---

**POST /api/secrets/:name**

**Purpose:** Create or update secret (web UI)

**Request:**
```json
{
  "value": "sk-proj-abc123..."
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "name": "openai_api_key",
    "version": 1,
    "created_at": "2025-10-16T14:00:00Z"
  }
}
```

---

**DELETE /api/secrets/:name**

**Purpose:** Delete secret (web UI)

**Response:**
```json
{
  "success": true,
  "data": {
    "deleted": true
  }
}
```

---

### Release Management

**GET /api/releases**

**Purpose:** List all releases for user

**Query Parameters:**
- `name={release_name}` - Filter by name (for CLI lookup)

**Response:**
```json
{
  "success": true,
  "data": {
    "releases": [
      {
        "id": "uuid-v4",
        "name": "my-openwebui",
        "git_url": "https://github.com/alice/quadlets",
        "git_branch": "main",
        "description": "OpenWebUI setup",
        "version": 1,
        "created_at": "2025-10-16T14:00:00Z",
        "updated_at": "2025-10-16T14:00:00Z"
      }
    ]
  }
}
```

---

**POST /api/releases**

**Purpose:** Create new release (web UI)

**Request:**
```json
{
  "name": "my-openwebui",
  "git_url": "https://github.com/alice/quadlets",
  "git_branch": "main",
  "description": "OpenWebUI with LiteLLM"
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "id": "uuid-v4",
    "name": "my-openwebui",
    "git_url": "https://github.com/alice/quadlets",
    "git_branch": "main",
    "version": 1,
    "created_at": "2025-10-16T14:00:00Z"
  }
}
```

---

**GET /api/releases/:id**

**Purpose:** Get single release details

**Response:**
```json
{
  "success": true,
  "data": {
    "id": "uuid-v4",
    "name": "my-openwebui",
    "git_url": "https://github.com/alice/quadlets",
    "git_branch": "main",
    "description": "OpenWebUI setup",
    "version": 1,
    "created_at": "2025-10-16T14:00:00Z",
    "updated_at": "2025-10-16T14:00:00Z"
  }
}
```

---

**PUT /api/releases/:id**

**Purpose:** Update release (web UI)

**Request:**
```json
{
  "git_url": "https://github.com/alice/quadlets-v2",
  "description": "Updated configuration"
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "id": "uuid-v4",
    "version": 2,
    "updated_at": "2025-10-17T10:00:00Z"
  }
}
```

---

**DELETE /api/releases/:id**

**Purpose:** Delete release (web UI)

**Response:**
```json
{
  "success": true,
  "data": {
    "deleted": true
  }
}
```

---

### Health Check

**GET /health** (Public, no auth)

**Response:**
```json
{
  "status": "healthy",
  "service": "leger-app",
  "version": "0.1.0",
  "timestamp": "2025-10-17T12:34:56Z"
}
```

---

## Frontend Pages

### Page Structure

```
/                          → Redirect to /api-keys
/auth                      → JWT validation landing page
/api-keys                  → Secret management (DEFAULT PAGE)
/releases                  → Release list
/releases/new              → Create release form
/releases/:id              → Release detail/edit
/settings                  → Account settings
```

**All routes except `/auth` require valid JWT in localStorage**

---

### 1. Auth Landing Page (`/auth`)

**URL:** `/auth?token={jwt}`

**Purpose:** Validate CLI-provided JWT and establish web session

**Layout:**
```
Full-screen loading spinner
"Validating authentication..."
```

**Logic:**
```typescript
// On mount
useEffect(() => {
  const params = new URLSearchParams(window.location.search);
  const token = params.get('token');
  
  if (!token) {
    navigate('/auth-error');
    return;
  }
  
  // Validate with backend
  fetch('/api/auth/validate', {
    headers: { 'Authorization': `Bearer ${token}` }
  })
    .then(res => res.json())
    .then(data => {
      localStorage.setItem('jwt', token);
      localStorage.setItem('user', JSON.stringify(data.user));
      navigate('/api-keys');
    })
    .catch(() => {
      navigate('/auth-error');
    });
}, []);
```

---

### 2. API Keys Page (`/api-keys`)

**URL:** `/api-keys`

**Purpose:** Manage API secrets

**Layout:**
```tsx
<PageLayout>
  <PageHeader
    title="API Keys & Integrations"
    description="Manage third-party API keys for AI services"
  />
  
  <CategorySection
    title="OpenAI"
    description="Configure OpenAI API access"
    isDirty={openaiDirty}
    onSave={saveOpenAI}
  >
    <FieldGroup>
      <SecretField
        label="API Key"
        value={openaiKey}
        onChange={setOpenaiKey}
      />
      <TextField
        label="Organization ID"
        value={openaiOrgId}
        onChange={setOpenaiOrgId}
        optional
      />
    </FieldGroup>
  </CategorySection>
  
  <CategorySection
    title="Anthropic"
    description="Configure Anthropic API access"
    isDirty={anthropicDirty}
    onSave={saveAnthropic}
  >
    <FieldGroup>
      <SecretField
        label="API Key"
        value={anthropicKey}
        onChange={setAnthropicKey}
      />
    </FieldGroup>
  </CategorySection>
  
  {/* More provider sections */}
</PageLayout>
```

**Features:**
- Independent save per provider section
- Secrets masked by default (show/hide toggle)
- Dirty state tracking
- Input validation

**API Calls:**
```typescript
// Save OpenAI key
const saveOpenAI = async () => {
  await fetch('/api/secrets/openai_api_key', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${jwt}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ value: openaiKey })
  });
  
  if (openaiOrgId) {
    await fetch('/api/secrets/openai_org_id', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${jwt}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ value: openaiOrgId })
    });
  }
  
  setOpenaiDirty(false);
  toast.success('OpenAI credentials saved');
};
```

---

### 3. Releases List Page (`/releases`)

**URL:** `/releases`

**Purpose:** List all saved releases (GitHub repos)

**Layout:**
```tsx
<PageLayout>
  <PageHeader
    title="Releases"
    description="Manage your quadlet deployment configurations"
    action={
      <Button onClick={() => navigate('/releases/new')}>
        <Plus className="h-4 w-4 mr-2" />
        Create Release
      </Button>
    }
  />
  
  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    {releases.map(release => (
      <Card key={release.id} className="hover:border-primary">
        <CardHeader>
          <CardTitle>{release.name}</CardTitle>
          <CardDescription>Version {release.version}</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-2 text-sm">
            <div className="flex items-center gap-2">
              <Github className="h-4 w-4" />
              <span className="truncate">{release.git_url}</span>
            </div>
            <div className="flex items-center gap-2">
              <GitBranch className="h-4 w-4" />
              <span>{release.git_branch}</span>
            </div>
            <div className="flex items-center gap-2">
              <Calendar className="h-4 w-4" />
              <span>{formatDate(release.updated_at)}</span>
            </div>
          </div>
        </CardContent>
        <CardFooter className="flex gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={() => navigate(`/releases/${release.id}`)}
          >
            Edit
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => copyDeployCommand(release.name)}
          >
            Copy Deploy Command
          </Button>
        </CardFooter>
      </Card>
    ))}
  </div>
  
  {releases.length === 0 && (
    <div className="text-center py-12">
      <h3 className="text-lg font-semibold mb-2">No releases yet</h3>
      <p className="text-muted-foreground mb-4">
        Create your first release to get started
      </p>
      <Button onClick={() => navigate('/releases/new')}>
        Create First Release
      </Button>
    </div>
  )}
</PageLayout>
```

---

### 4. Create/Edit Release Page (`/releases/new`, `/releases/:id`)

**URL:** `/releases/new` or `/releases/:id`

**Purpose:** Create or edit release metadata

**Layout:**
```tsx
<PageLayout>
  <PageHeader
    title={isNew ? "Create Release" : "Edit Release"}
    description="Configure your quadlet deployment source"
  />
  
  <CategorySection
    title="Release Information"
    isDirty={isDirty}
    onSave={saveRelease}
  >
    <FieldGroup>
      <TextField
        label="Release Name"
        description="Unique identifier for this release"
        value={form.name}
        onChange={v => setForm({...form, name: v})}
        error={errors.name}
      />
      
      <URLInput
        label="Git Repository URL"
        description="GitHub, GitLab, or other git repository"
        placeholder="https://github.com/username/repo"
        value={form.git_url}
        onChange={v => setForm({...form, git_url: v})}
        error={errors.git_url}
      />
      
      <TextField
        label="Git Branch"
        description="Branch to clone (default: main)"
        value={form.git_branch}
        onChange={v => setForm({...form, git_branch: v})}
        placeholder="main"
      />
      
      <TextArea
        label="Description"
        description="Optional description of this release"
        value={form.description}
        onChange={v => setForm({...form, description: v})}
        optional
        rows={3}
      />
    </FieldGroup>
  </CategorySection>
  
  <Card className="bg-blue-50 dark:bg-blue-950 border-blue-200 dark:border-blue-800">
    <CardHeader>
      <CardTitle className="text-blue-900 dark:text-blue-100">
        Deploy Command
      </CardTitle>
    </CardHeader>
    <CardContent>
      <div className="font-mono text-sm bg-background p-3 rounded">
        $ leger deploy install --release {form.name || 'release-name'}
      </div>
      <Button
        variant="outline"
        size="sm"
        className="mt-2"
        onClick={() => copyToClipboard(deployCommand)}
      >
        <Copy className="h-4 w-4 mr-2" />
        Copy Command
      </Button>
    </CardContent>
  </Card>
</PageLayout>
```

**API Calls:**
```typescript
const saveRelease = async () => {
  const endpoint = isNew 
    ? '/api/releases'
    : `/api/releases/${releaseId}`;
  
  const method = isNew ? 'POST' : 'PUT';
  
  const response = await fetch(endpoint, {
    method,
    headers: {
      'Authorization': `Bearer ${jwt}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(form)
  });
  
  const data = await response.json();
  
  if (data.success) {
    toast.success('Release saved');
    navigate('/releases');
  } else {
    setErrors(data.error);
  }
};
```

---

### 5. Settings Page (`/settings`)

**URL:** `/settings`

**Purpose:** Account information and preferences

**Layout:**
```tsx
<PageLayout>
  <PageHeader
    title="Settings"
    description="Manage your account and preferences"
  />
  
  <CategorySection
    title="Profile"
    description="Your Leger account information"
  >
    <FieldGroup>
      <div className="flex items-center gap-2">
        <span className="text-muted-foreground">Email:</span>
        <span className="font-medium">{user.email}</span>
      </div>
      <div className="flex items-center gap-2">
        <span className="text-muted-foreground">Tailnet:</span>
        <span className="font-medium">{user.tailnet}</span>
      </div>
    </FieldGroup>
  </CategorySection>
  
  <CategorySection
    title="Leger ID"
    description="Your unique user identifier"
  >
    <FieldGroup>
      <div className="flex items-center gap-2">
        <Input
          value={user.user_uuid}
          readOnly
          className="font-mono text-sm"
        />
        <Button
          variant="outline"
          size="icon"
          onClick={() => copyToClipboard(user.user_uuid)}
        >
          <Copy className="h-4 w-4" />
        </Button>
      </div>
    </FieldGroup>
  </CategorySection>
  
  <CategorySection
    title="Display Name"
    description="How your name appears in Leger"
    isDirty={displayNameDirty}
    onSave={saveDisplayName}
  >
    <FieldGroup>
      <TextField
        label="Display Name"
        value={displayName}
        onChange={setDisplayName}
        maxLength={32}
        showCharCount
      />
    </FieldGroup>
  </CategorySection>
</PageLayout>
```

---

## Infrastructure Setup

### Cloudflare Resources

**1. Create KV Namespaces:**
```bash
wrangler kv:namespace create "LEGER_USERS"
wrangler kv:namespace create "LEGER_USERS" --preview

wrangler kv:namespace create "LEGER_SECRETS"
wrangler kv:namespace create "LEGER_SECRETS" --preview
```

**2. Create R2 Bucket:**
```bash
wrangler r2 bucket create leger-static-sites
```

**3. Create D1 Database:**
```bash
wrangler d1 create leger-db
```

**4. Apply D1 Migrations:**
```bash
wrangler d1 execute leger-db --file=./db/migrations/0001_initial.sql
```

**5. Set Secrets:**
```bash
wrangler secret put ENCRYPTION_KEY
# Enter: base64-encoded 256-bit key

wrangler secret put JWT_SECRET
# Enter: shared secret (same as CLI uses)
```

---

### Wrangler Configuration

**File:** `wrangler.toml`

```toml
name = "leger-app"
compatibility_date = "2025-04-01"
main = "api/index.ts"

[assets]
directory = "./dist"
binding = "ASSETS"
not_found_handling = "single-page-application"

[[kv_namespaces]]
binding = "LEGER_USERS"
id = "your-kv-id-here"

[[kv_namespaces]]
binding = "LEGER_SECRETS"
id = "your-kv-id-here"

[[r2_buckets]]
binding = "LEGER_STATIC"
bucket_name = "leger-static-sites"

[[d1_databases]]
binding = "LEGER_DB"
database_name = "leger-db"
database_id = "your-db-id-here"

[vars]
ENVIRONMENT = "production"
APP_VERSION = "0.1.0"

[placement]
mode = "smart"
```

**Environment Interface:**
```typescript
export interface Env {
  ASSETS: Fetcher;
  LEGER_USERS: KVNamespace;
  LEGER_SECRETS: KVNamespace;
  LEGER_STATIC: R2Bucket;
  LEGER_DB: D1Database;
  ENVIRONMENT: string;
  APP_VERSION: string;
  ENCRYPTION_KEY: string;
  JWT_SECRET: string;
}
```

---

### Build Configuration

**package.json:**
```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build && npm run build:worker",
    "build:worker": "esbuild api/index.ts --bundle --format=esm --outfile=dist/_worker.js --platform=neutral --target=es2020 --minify",
    "deploy": "npm run build && wrangler deploy",
    "db:migrate": "wrangler d1 execute leger-db --file=./db/migrations/0001_initial.sql"
  }
}
```

---

## Deployment

### GitHub Actions

**File:** `.github/workflows/deploy.yml`

```yaml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Type check
        run: npm run typecheck
      
      - name: Build
        run: npm run build
      
      - name: Deploy to Cloudflare
        run: wrangler deploy
        env:
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      
      - name: Health check
        run: |
          sleep 10
          curl -f https://app.leger.run/health || exit 1
```

---

## Success Criteria

### Functional Requirements

- [ ] User runs `leger auth login` → Browser opens with JWT → Web session established
- [ ] User creates secret "openai_api_key" via web UI → Stored encrypted in KV
- [ ] User runs `leger secrets sync` → CLI fetches secrets from KV (decrypted)
- [ ] CLI writes secrets to local setec → legerd creates Podman secrets
- [ ] User creates release with GitHub URL → Stored in D1
- [ ] User views releases in web UI → List shows all releases
- [ ] CLI fetches release metadata → Gets GitHub URL → Clones repo
- [ ] CLI deploys from cloned repo → Uses native Podman commands

### Infrastructure Validation

- [ ] KV namespaces created and bound to Worker
- [ ] R2 bucket created (empty, ready for v0.2.0)
- [ ] D1 database created with all tables (including future v0.2.0 tables)
- [ ] Secrets configured (ENCRYPTION_KEY, JWT_SECRET)
- [ ] GitHub Actions deploys successfully
- [ ] Health check returns 200 OK

### Security Validation

- [ ] Secrets encrypted at rest in KV
- [ ] JWT signature validated on all protected routes
- [ ] No plaintext secrets in logs
- [ ] Master key never exposed
- [ ] CLI and backend use same JWT secret

### End-to-End Test

1. Fresh user with Tailscale running
2. Run `leger auth login`
   - CLI generates JWT
   - Browser opens to app.leger.run
   - Web session established
3. Visit app.leger.run/api-keys
   - Create secret "test_key" with value "test123"
   - Save successfully
4. Terminal: `leger secrets sync`
   - CLI fetches secret from KV
   - Writes to local setec
5. Terminal: `podman secret ls`
   - Verify "test_key" exists
6. Visit app.leger.run/releases
   - Create release pointing to GitHub repo
   - Save successfully
7. Terminal: `leger deploy install --release {name}`
   - CLI fetches release metadata
   - CLI clones from GitHub
   - CLI installs quadlets

**If all steps pass → v0.1.0 complete**

---

## Document Metadata

**Version:** 3.0 (Complete Rewrite)  
**Status:** Production specification aligned with CLI  
**Last Updated:** October 2025

**Key Changes from v2.0:**
- Removed all "bundle" terminology and upload/download APIs
- Clarified JWT flow (CLI-generated, shared secret)
- Secret sync is KV→CLI→setec→Podman (one direction)
- Releases are GitHub URLs in v0.1.0
- R2 bucket exists but empty (infrastructure only)
- No Tailscale API verification (JWT self-contained)
- Aligned with production CLI implementation
