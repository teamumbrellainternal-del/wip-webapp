import type { EnvVariable } from '@/types'

// Enhanced ENV file formatting utilities
export interface FormattingOptions {
  sortKeys?: boolean
  groupByPrefix?: boolean
  addSectionHeaders?: boolean
  preserveComments?: boolean
  indentSize?: number
  maxLineLength?: number
  emptyLineBetweenSections?: boolean
  headerComment?: string
}

// Format ENV content with comprehensive styling options
export function formatEnvWithStyle(
  content: string,
  options: FormattingOptions = {}
): string {
  const {
    sortKeys = true,
    groupByPrefix = true,
    addSectionHeaders = true,
    preserveComments = true,
    indentSize = 0,
    maxLineLength = 120,
    emptyLineBetweenSections = true,
    headerComment = 'OpenWebUI Configuration\nGenerated by openwebui-config.com'
  } = options

  const variables = parseEnvVariables(content)
  const indent = ' '.repeat(indentSize)
  
  if (groupByPrefix) {
    return formatGroupedEnv(variables, {
      sortKeys,
      addSectionHeaders,
      preserveComments,
      indent,
      maxLineLength,
      emptyLineBetweenSections,
      headerComment
    })
  }

  return formatSimpleEnv(variables, {
    sortKeys,
    preserveComments,
    indent,
    maxLineLength,
    headerComment
  })
}

// Parse ENV content into structured variables
function parseEnvVariables(content: string): EnvVariable[] {
  const variables: EnvVariable[] = []
  const lines = content.split('\n')
  
  let currentComment = ''

  for (const line of lines) {
    const trimmed = line.trim()
    
    if (!trimmed) {
      // Reset comment on empty lines
      if (currentComment && !currentComment.includes('\n')) {
        currentComment = ''
      }
      continue
    }
    
    if (trimmed.startsWith('#')) {
      // Accumulate comments
      const commentText = trimmed.substring(1).trim()
      if (currentComment) {
        currentComment += '\n' + commentText
      } else {
        currentComment = commentText
      }
      continue
    }
    
    const equalIndex = trimmed.indexOf('=')
    if (equalIndex === -1) {
      // Reset comment on invalid lines
      currentComment = ''
      continue
    }
    
    const key = trimmed.substring(0, equalIndex).trim()
    const value = trimmed.substring(equalIndex + 1).trim()
    
    if (key) {
      // Clean quotes from value
      let cleanValue = value
      if ((cleanValue.startsWith('"') && cleanValue.endsWith('"')) ||
          (cleanValue.startsWith("'") && cleanValue.endsWith("'"))) {
        cleanValue = cleanValue.slice(1, -1)
      }
      
      variables.push({
        key,
        value: cleanValue,
        comment: currentComment || undefined
      })
      
      currentComment = ''
    }
  }
  
  return variables
}

// Format with grouping by prefix
function formatGroupedEnv(
  variables: EnvVariable[],
  options: {
    sortKeys: boolean
    addSectionHeaders: boolean
    preserveComments: boolean
    indent: string
    maxLineLength: number
    emptyLineBetweenSections: boolean
    headerComment: string
  }
): string {
  const result: string[] = []
  
  // Add header
  if (options.headerComment) {
    options.headerComment.split('\n').forEach(line => {
      result.push(`${options.indent}# ${line}`)
    })
    result.push('')
  }
  
  // Group variables by prefix
  const groups = groupVariablesByPrefix(variables)
  const ungrouped = groups.get('') || []
  
  // Add ungrouped variables first
  if (ungrouped.length > 0) {
    if (options.addSectionHeaders) {
      result.push(`${options.indent}# General Configuration`)
    }
    
    const sortedUngrouped = options.sortKeys
      ? ungrouped.sort((a, b) => a.key.localeCompare(b.key))
      : ungrouped
    
    addVariablesToResult(result, sortedUngrouped, options)
    
    if (options.emptyLineBetweenSections && groups.size > 1) {
      result.push('')
    }
  }
  
  // Add grouped variables
  const sortedGroupKeys = Array.from(groups.keys())
    .filter(key => key !== '')
    .sort()
  
  sortedGroupKeys.forEach((groupKey, index) => {
    const groupVariables = groups.get(groupKey)!
    
    if (options.addSectionHeaders) {
      const headerText = formatSectionHeader(groupKey)
      result.push(`${options.indent}# ${headerText}`)
    }
    
    const sortedVariables = options.sortKeys
      ? groupVariables.sort((a, b) => a.key.localeCompare(b.key))
      : groupVariables
    
    addVariablesToResult(result, sortedVariables, options)
    
    if (options.emptyLineBetweenSections && index < sortedGroupKeys.length - 1) {
      result.push('')
    }
  })
  
  return result.join('\n').trim() + '\n'
}

// Format without grouping
function formatSimpleEnv(
  variables: EnvVariable[],
  options: {
    sortKeys: boolean
    preserveComments: boolean
    indent: string
    maxLineLength: number
    headerComment: string
  }
): string {
  const result: string[] = []
  
  // Add header
  if (options.headerComment) {
    options.headerComment.split('\n').forEach(line => {
      result.push(`${options.indent}# ${line}`)
    })
    result.push('')
  }
  
  const sortedVariables = options.sortKeys
    ? variables.sort((a, b) => a.key.localeCompare(b.key))
    : variables
  
  addVariablesToResult(result, sortedVariables, options)
  
  return result.join('\n').trim() + '\n'
}

// Group variables by their prefix
function groupVariablesByPrefix(variables: EnvVariable[]): Map<string, EnvVariable[]> {
  const groups = new Map<string, EnvVariable[]>()
  
  variables.forEach(variable => {
    const prefix = extractVariablePrefix(variable.key)
    const groupKey = prefix || ''
    
    if (!groups.has(groupKey)) {
      groups.set(groupKey, [])
    }
    groups.get(groupKey)!.push(variable)
  })
  
  return groups
}

// Extract prefix from variable key
function extractVariablePrefix(key: string): string | null {
  const prefixPatterns = [
    // Multi-word prefixes
    /^(OAUTH|OPENAI|WEBUI|AUDIO|IMAGE|CODE|USER_PERMISSIONS|RAG|LDAP|DATABASE|WEBSOCKET)_/,
    // Single word prefixes
    /^(GOOGLE|MICROSOFT|GITHUB|CHROMA|MILVUS|ELASTICSEARCH|OPENSEARCH|QDRANT|PINECONE|PGVECTOR|S3|AZURE|GCS|REDIS)_/,
    // Special cases
    /^(ENABLE)_/,
    /^(DEFAULT)_/
  ]
  
  for (const pattern of prefixPatterns) {
    const match = key.match(pattern)
    if (match) {
      return match[1]
    }
  }
  
  return null
}

// Add variables to result array with proper formatting
function addVariablesToResult(
  result: string[],
  variables: EnvVariable[],
  options: {
    preserveComments: boolean
    indent: string
    maxLineLength: number
  }
): void {
  variables.forEach(variable => {
    // Add comments if preserving them
    if (options.preserveComments && variable.comment) {
      const commentLines = variable.comment.split('\n')
      commentLines.forEach(commentLine => {
        const wrappedComments = wrapComment(commentLine.trim(), options.maxLineLength, options.indent)
        wrappedComments.forEach(line => result.push(line))
      })
    }
    
    // Format the variable line
    const formattedLine = formatVariableLine(variable, options.indent, options.maxLineLength)
    result.push(formattedLine)
  })
}

// Format a single variable line
function formatVariableLine(variable: EnvVariable, indent: string, maxLineLength: number): string {
  const needsQuoting = shouldQuoteValue(variable.value)
  const escapedValue = needsQuoting ? `"${escapeForQuotes(variable.value)}"` : variable.value
  const line = `${indent}${variable.key}=${escapedValue}`
  
  // If line is too long, format it nicely
  if (line.length > maxLineLength && needsQuoting) {
    // For long quoted strings, we could add line continuation, but ENV doesn't support it well
    // So we'll just return the line as-is with a note
    return line
  }
  
  return line
}

// Wrap comment text to fit within line length
function wrapComment(comment: string, maxLineLength: number, indent: string): string[] {
  const prefix = `${indent}# `
  const availableLength = maxLineLength - prefix.length
  
  if (comment.length <= availableLength) {
    return [`${prefix}${comment}`]
  }
  
  const words = comment.split(' ')
  const lines: string[] = []
  let currentLine = ''
  
  words.forEach(word => {
    if (currentLine && (currentLine + ' ' + word).length > availableLength) {
      lines.push(`${prefix}${currentLine}`)
      currentLine = word
    } else {
      currentLine = currentLine ? `${currentLine} ${word}` : word
    }
  })
  
  if (currentLine) {
    lines.push(`${prefix}${currentLine}`)
  }
  
  return lines
}

// Format section headers
function formatSectionHeader(prefix: string): string {
  const formatted = prefix
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ')
  
  return `${formatted} Configuration`
}

// Check if value needs quoting
function shouldQuoteValue(value: string): boolean {
  // Quote if contains spaces, special chars, or is empty
  return /[\s#"'\\$`]/.test(value) || value === ''
}

// Escape value for double quotes
function escapeForQuotes(value: string): string {
  return value
    .replace(/\\/g, '\\\\')  // Escape backslashes
    .replace(/"/g, '\\"')    // Escape double quotes
    .replace(/\n/g, '\\n')   // Escape newlines
    .replace(/\t/g, '\\t')   // Escape tabs
}

// Create template ENV content with common sections
export function createTemplateEnv(includeExamples: boolean = false): string {
  const template = `# OpenWebUI Configuration Template
# Generated by openwebui-config.com
# 
# Copy this template and fill in your values
# Remove or comment out sections you don't need

# =============================================================================
# GENERAL CONFIGURATION
# =============================================================================

# Basic server settings
WEBUI_URL=http://localhost:8080
WEBUI_NAME=OpenWebUI
PORT=8080
ENV=prod

# Authentication
WEBUI_AUTH=true
WEBUI_SECRET_KEY=${includeExamples ? 'your-secret-key-here' : ''}

# =============================================================================
# USER MANAGEMENT
# =============================================================================

# User registration and roles
ENABLE_SIGNUP=${includeExamples ? 'false' : ''}
DEFAULT_USER_ROLE=${includeExamples ? 'user' : ''}
ADMIN_EMAIL=${includeExamples ? 'admin@yourdomain.com' : ''}

# =============================================================================
# OAUTH CONFIGURATION
# =============================================================================

# Enable OAuth signup
ENABLE_OAUTH_SIGNUP=${includeExamples ? 'false' : ''}

# Google OAuth
GOOGLE_CLIENT_ID=${includeExamples ? 'your-google-client-id' : ''}
GOOGLE_CLIENT_SECRET=${includeExamples ? 'your-google-client-secret' : ''}

# =============================================================================
# OPENAI API CONFIGURATION
# =============================================================================

# OpenAI integration
ENABLE_OPENAI_API=${includeExamples ? 'false' : ''}
OPENAI_API_BASE_URL=${includeExamples ? 'https://api.openai.com/v1' : ''}
OPENAI_API_KEY=${includeExamples ? 'sk-your-openai-api-key' : ''}

# =============================================================================
# RAG (Retrieval Augmented Generation) CONFIGURATION
# =============================================================================

# Vector database
VECTOR_DB=${includeExamples ? 'chroma' : ''}

# Chroma settings (if using chroma)
CHROMA_HTTP_HOST=${includeExamples ? 'localhost' : ''}
CHROMA_HTTP_PORT=${includeExamples ? '8000' : ''}

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================

# Database connection
DATABASE_URL=${includeExamples ? 'sqlite:///app/backend/data/webui.db' : ''}

# =============================================================================
# ADDITIONAL FEATURES
# =============================================================================

# Image generation
ENABLE_IMAGE_GENERATION=${includeExamples ? 'false' : ''}

# Web search
ENABLE_WEB_SEARCH=${includeExamples ? 'false' : ''}

# Audio features
AUDIO_TTS_ENGINE=${includeExamples ? 'openai' : ''}
AUDIO_STT_ENGINE=${includeExamples ? 'openai' : ''}
`

  return template
}

// Validate ENV format and provide formatting suggestions
export function validateAndSuggestFormatting(content: string): {
  isValid: boolean
  errors: string[]
  suggestions: string[]
  formattedContent?: string
} {
  const errors: string[] = []
  const suggestions: string[] = []
  const lines = content.split('\n')
  
  let hasErrors = false
  let needsFormatting = false
  
  lines.forEach((line, index) => {
    const trimmed = line.trim()
    const lineNum = index + 1
    
    if (!trimmed || trimmed.startsWith('#')) {
      return // Skip empty lines and comments
    }
    
    // Check for missing equals sign
    if (!trimmed.includes('=')) {
      errors.push(`Line ${lineNum}: Missing '=' character`)
      hasErrors = true
      return
    }
    
    const equalIndex = trimmed.indexOf('=')
    const key = trimmed.substring(0, equalIndex).trim()
    const value = trimmed.substring(equalIndex + 1).trim()
    
    // Check for empty key
    if (!key) {
      errors.push(`Line ${lineNum}: Empty variable name`)
      hasErrors = true
    }
    
    // Check for invalid key characters
    if (key && !/^[A-Z_][A-Z0-9_]*$/.test(key)) {
      suggestions.push(`Line ${lineNum}: Variable name '${key}' should use UPPER_CASE with underscores`)
      needsFormatting = true
    }
    
    // Check for unquoted values that might need quotes
    if (value && /[\s#]/.test(value) && !((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'")))) {
      suggestions.push(`Line ${lineNum}: Value '${value}' contains spaces or special characters and should be quoted`)
      needsFormatting = true
    }
  })
  
  let formattedContent: string | undefined
  if (!hasErrors && (needsFormatting || suggestions.length === 0)) {
    try {
      formattedContent = formatEnvWithStyle(content, {
        sortKeys: true,
        groupByPrefix: true,
        addSectionHeaders: true
      })
    } catch (error) {
      suggestions.push('Could not automatically format content due to syntax errors')
    }
  }
  
  return {
    isValid: !hasErrors,
    errors,
    suggestions,
    formattedContent
  }
}